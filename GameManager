local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

print("üéÆ GameManager Script Starting...")

-- Wait for RemoteEventSetup to finish
task.wait(0.5)

-- Load GameModes Module
print("üì¶ Looking for GameModes module...")
local GameModes = require(script.Parent:WaitForChild("GameModes", 10))
if not GameModes then
	error("‚ùå CRITICAL: GameModes module not found!")
end
print("‚úÖ GameModes module loaded!")

local CONFIG = {
	MIN_PLAYERS = 2,
	INTERMISSION_TIME = 10,
	ROUND_START_GUI_TIME = 4, -- Time for round start GUI to show
	ROUND_END_GUI_TIME = 6, -- Time for round end GUI to show
}

-- Wait for RemoteEvents (they should already exist)
print("üì° Waiting for RemoteEvents...")
local updateStatusEvent = ReplicatedStorage:WaitForChild("UpdateStatus", 10)
local gameStateEvent = ReplicatedStorage:WaitForChild("GameState", 10)
local updateGameModeEvent = ReplicatedStorage:WaitForChild("UpdateGameMode", 10)
local playerReadyEvent = ReplicatedStorage:WaitForChild("PlayerReady", 10)
local updateChaserEvent = ReplicatedStorage:WaitForChild("UpdateChaser", 10)
local updateSkinEvent = ReplicatedStorage:WaitForChild("UpdateSkin", 10)
local useAbilityEvent = ReplicatedStorage:WaitForChild("UseAbility", 10)

if not updateStatusEvent or not gameStateEvent or not updateGameModeEvent or not playerReadyEvent then
	error("‚ùå CRITICAL: Required RemoteEvents not found! Make sure RemoteEventSetup runs first!")
end

print("‚úÖ All RemoteEvents found!")

-- Wait for BindableEvents
local serverComm = ReplicatedStorage:WaitForChild("ServerGameState", 10)
if not serverComm then
	error("‚ùå CRITICAL: ServerGameState BindableEvent not found!")
end

-- Game state variables
local gameActive = false
local intermissionActive = false
local currentGameMode = "Role Swap"
local allChasers = {}
local roundEndScheduled = false
local waitingForGUI = false -- NEW: Track if we're waiting for GUI

-- Player readiness tracking
local readyPlayers = {}

-- Function to check if player is ready
local function isPlayerReady(player)
	return readyPlayers[player.UserId] == true
end

-- Function to update game mode for all players
local function updateGameMode(mode)
	currentGameMode = mode
	updateGameModeEvent:FireAllClients(mode)
	print("üéÆ Game mode set to: " .. mode)
end

-- Function to choose random game mode (uses GameModes module)
local function chooseRandomGameMode()
	local mode = GameModes.GetRandomMode()
	currentGameMode = mode.Name
	updateGameMode(mode.Name)

	-- Notify MainLogic of the game mode via BindableEvent
	local gameModeComm = ReplicatedStorage:FindFirstChild("GameModeUpdate")
	if gameModeComm then
		gameModeComm:Fire(mode.Name)
		print("üéÆ GameManager notified MainLogic: " .. mode.Name)
	end

	print("üéÆ Selected game mode: " .. mode.Icon .. " " .. mode.Name)
	return mode.Name
end

-- Function to get count of ready players
local function getReadyPlayerCount()
	local count = 0
	for _, player in ipairs(Players:GetPlayers()) do
		if isPlayerReady(player) then
			count = count + 1
		end
	end
	return count
end

-- Function to update status for all players
local function updateStatus(message, isIntermission)
	updateStatusEvent:FireAllClients(message, isIntermission)
	print("üì¢ Status updated: " .. message)
end

-- Function to end the current round (with optional winner override)
local function endRound(winnerOverride)
	if not gameActive then 
		print("‚ö†Ô∏è endRound called but gameActive is already false")
		return 
	end

	gameActive = false -- This will stop the round timer
	roundEndScheduled = false
	intermissionActive = false
	waitingForGUI = true -- NEW: Set flag to prevent intermission
	allChasers = {}
	print("üèÅ Round ended!")

	-- If winner override is provided, use it (for early victories)
	if winnerOverride then
		print("üèÜ Round ended early with winner: " .. winnerOverride)
	else
		updateStatus("Round over! Returning to lobby...", false)
	end

	-- Signal clients and main game script (they will show GUI and teleport)
	gameStateEvent:FireAllClients("end")
	serverComm:Fire("end")

	-- Wait for round end GUI to finish (6 seconds)
	print("‚è∏Ô∏è Waiting for round end GUI to finish (" .. CONFIG.ROUND_END_GUI_TIME .. " seconds)...")
	wait(CONFIG.ROUND_END_GUI_TIME)
	print("‚úÖ Round end GUI finished!")

	waitingForGUI = false -- NEW: Clear flag to allow intermission
	updateStatus("Waiting for players...", false)

	-- ‚úÖ ADD THIS: Immediately check if we can start next round
	print("üîÑ Checking if we can start next round...")
	task.spawn(function()
		wait(0.5) -- Small delay to let everything settle
		checkPlayerCount()
	end)
end

-- Listen for signals FROM MainLogic
serverComm.Event:Connect(function(state, data)
	print("üì° GameManager received signal from MainLogic: " .. tostring(state))
	if state == "end" then
		print("üîî MainLogic requested game end - calling endRound()")
		if gameActive then
			-- Check if there's a winner override (for early victories)
			local winnerMessage = nil
			if data and data.winner then
				winnerMessage = data.winner
			end
			endRound(winnerMessage)
		else
			print("‚ö†Ô∏è Game already inactive, ignoring end signal")
		end
	end
end)

-- Function to start round (uses GameModes module)
local function startRound()
	if gameActive or roundEndScheduled then 
		print("‚ö†Ô∏è Cannot start round - gameActive: " .. tostring(gameActive) .. ", roundEndScheduled: " .. tostring(roundEndScheduled))
		return 
	end

	gameActive = true
	intermissionActive = false
	roundEndScheduled = true

	chooseRandomGameMode()

	-- Use GameModes module to get round time
	local roundTime = GameModes.GetRoundTime(currentGameMode)

	print("üöÄ Round starting! Mode: " .. currentGameMode)
	print("üì° Firing game start events...")

	-- Use GameModes module for status message
	updateStatus(GameModes.GetStatusMessage(currentGameMode), false)

	-- Fire events (MainLogic will show GUI, teleport, and wait for GUI to finish)
	gameStateEvent:FireAllClients("start")

	if serverComm then
		print("üì¢ Firing ServerGameState with 'start' signal...")
		serverComm:Fire("start")
		print("‚úÖ ServerGameState fired!")
	else
		warn("‚ùå CRITICAL: serverComm is nil!")
	end

	-- Wait for round start GUI to finish before starting timer
	print("‚è∏Ô∏è Waiting for round start GUI to finish (" .. CONFIG.ROUND_START_GUI_TIME .. " seconds)...")
	wait(CONFIG.ROUND_START_GUI_TIME)
	print("‚ñ∂Ô∏è Starting round timer NOW!")

	-- Replace the round timer section in GameManager.startRound()
	-- Find this section and replace it:

	-- Set round timer (starts AFTER GUI finishes)
	task.spawn(function()
		for i = roundTime, 1, -1 do
			wait(1)

			-- Check if game was ended early
			if not gameActive then 
				print("‚èπÔ∏è Round timer stopped early at " .. i .. " seconds remaining")
				return  -- Exit immediately, MainLogic already handled cleanup
			end

			if i <= 10 then
				updateStatus("ü¶¥ ROUND ENDING IN " .. i .. " ü¶¥", false)
			end
		end

		-- Final check before ending
		if not gameActive then 
			print("‚èπÔ∏è Round timer stopped at end")
			return  -- Don't call endRound if game already ended
		end

		-- Timer reached 0 naturally - show final message
		local winner = GameModes.HasEarlyEndCondition(currentGameMode) and "survivors" or nil
		updateStatus(GameModes.GetWinMessage(currentGameMode, winner), false)

		wait(1)

		-- CRITICAL: Check AGAIN before calling endRound (prevent double-end)
		if gameActive then
			print("‚è∞ Round timer finished naturally - calling endRound()")
			endRound()
		else
			print("‚è∞ Round already ended by win condition - skipping endRound()")
		end
	end)

	print("‚úÖ Round active for " .. roundTime .. " seconds (after GUI)")
end

-- Function to start intermission
local function startIntermission()
	if intermissionActive or gameActive or waitingForGUI then -- NEW: Check waitingForGUI flag
		if waitingForGUI then
			print("‚è∏Ô∏è Cannot start intermission - waiting for round end GUI to finish")
		end
		return
	end

	intermissionActive = true
	print("‚è∞ Intermission started! Round begins in " .. CONFIG.INTERMISSION_TIME .. " seconds.")

	for i = CONFIG.INTERMISSION_TIME, 1, -1 do
		local readyCount = getReadyPlayerCount()
		if readyCount < CONFIG.MIN_PLAYERS then
			intermissionActive = false
			checkPlayerCount()
			return
		end

		updateStatus("Round starting in: " .. i, true)
		wait(1)
	end

	if getReadyPlayerCount() >= CONFIG.MIN_PLAYERS then
		startRound()
	else
		intermissionActive = false
		checkPlayerCount()
	end
end

-- Function to check player count and update status
function checkPlayerCount()
	-- Don't check if game is active, intermission is running, OR waiting for GUI
	if gameActive or intermissionActive or waitingForGUI then -- NEW: Added waitingForGUI check
		return
	end

	local readyCount = getReadyPlayerCount()
	local totalCount = #Players:GetPlayers()

	print("üîç Checking player count - Ready: " .. readyCount .. " / Total: " .. totalCount)

	if readyCount < CONFIG.MIN_PLAYERS then
		if totalCount > readyCount then
			updateStatus(readyCount .. "/" .. CONFIG.MIN_PLAYERS .. " players ready (loading: " .. (totalCount - readyCount) .. ")", false)
		else
			updateStatus(readyCount .. "/" .. CONFIG.MIN_PLAYERS .. " More players needed", false)
		end
	elseif readyCount >= CONFIG.MIN_PLAYERS and not roundEndScheduled then
		print("‚úÖ Enough players! Starting intermission...")
		startIntermission()
	end
end

-- Listen for player ready signal
playerReadyEvent.OnServerEvent:Connect(function(player)
	if not readyPlayers[player.UserId] then
		readyPlayers[player.UserId] = true
		print("‚úÖ " .. player.Name .. " is now ready! (" .. getReadyPlayerCount() .. " ready)")

		task.spawn(function()
			wait(0.5)
			checkPlayerCount()
		end)
	end
end)

-- Player joined
Players.PlayerAdded:Connect(function(player)
	print("üëã " .. player.Name .. " joined the game! (Loading...)")

	readyPlayers[player.UserId] = false

	wait(0.5)
	updateGameModeEvent:FireClient(player, currentGameMode)

	wait(0.5)
	checkPlayerCount()
end)

-- Player left
Players.PlayerRemoving:Connect(function(player)
	print("üëã " .. player.Name .. " left the game!")

	readyPlayers[player.UserId] = nil

	wait(0.1)
	checkPlayerCount()
end)

-- Initial setup
print("üéÆ GameManager Script Loaded!")
updateGameMode("Role Swap")

-- Check for existing players
for _, player in ipairs(Players:GetPlayers()) do
	readyPlayers[player.UserId] = false
	wait(0.5)
	updateGameModeEvent:FireClient(player, currentGameMode)
end

-- Always check player count on loop
task.spawn(function()
	wait(3)
	while true do
		checkPlayerCount()
		wait(2)
	end
end)



-- Expose functions for other scripts
local module = {}
module.IsGameActive = function()
	return gameActive
end
module.EndGame = function()
	endRound()
end
module.IsPlayerReady = function(player)
	return isPlayerReady(player)
end
module.GetCurrentGameMode = function()
	return currentGameMode
end
module.GetAllChasers = function()
	return allChasers
end

return module
