
-- At the top of MainLogic, replace the event creation section with this:

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

print("üéÆ MainLogic Loading...")

-- Wait for RemoteEventSetup to finish
task.wait(1)

-- Load Gun System Module
local GunSystem = require(script.Parent:WaitForChild("GunSystem"))

-- Load Chaser Abilities Module
local ChaserAbilities = require(script.Parent:WaitForChild("ChaserAbilitiesSystem"))

-- Load GameModes Module
local GameModes = require(script.Parent:WaitForChild("GameModes"))


-- Load Animation Handler Module
local AnimationHandler = require(script.Parent:WaitForChild("AnimationHandler"))
local Map2EscapeSystem = require(script.Parent:WaitForChild("Map2EscapeSystem"))


-- Get spawn points
local Maps = Workspace:WaitForChild("Maps")
local SpawnPoints = Maps:WaitForChild("SpawnPoints")
local LobbySpawn = SpawnPoints:WaitForChild("Lobby")
local Map1S = SpawnPoints:WaitForChild("Map1S")
local Map1K = SpawnPoints:WaitForChild("Map1K")
local Map2S = SpawnPoints:WaitForChild("Map2S")
local Map2K = SpawnPoints:WaitForChild("Map2K")
local Map3S = SpawnPoints:WaitForChild("Map3S")
local Map3K = SpawnPoints:WaitForChild("Map3K")

-- Current map being used
local currentMap = nil

-- Wait for RemoteEvents (should already exist from RemoteEventSetup)
print("üì° MainLogic: Waiting for RemoteEvents...")
local updateChaserEvent = ReplicatedStorage:WaitForChild("UpdateChaser", 10)
local updateSkinEvent = ReplicatedStorage:WaitForChild("UpdateSkin", 10)
local gameStateEvent = ReplicatedStorage:WaitForChild("GameState", 10)

if not updateChaserEvent or not updateSkinEvent or not gameStateEvent then
	error("‚ùå MainLogic: Required RemoteEvents not found!")
end

print("‚úÖ MainLogic: All RemoteEvents found!")

if not updateSkinEvent then
	updateSkinEvent = Instance.new("RemoteEvent")
	updateSkinEvent.Name = "UpdateSkin"
	updateSkinEvent.Parent = ReplicatedStorage
end



-- All Pibble skin variations
local PIBBLE_SKINS = {
	{
		Name = "Pibble Burger",
		Head = 88261712741830,
		Torso = 121025911233801,
		LeftArm = 71134332361472,
		RightArm = 101419799228393,
		LeftLeg = 95256684949638,
		RightLeg = 130285760815104,
	},
	{
		Name = "Pitbull Puppy",
		Head = 83197599511005,
		Torso = 140500982398109,
		LeftArm = 77580285631556,
		RightArm = 88043956710030,
		LeftLeg = 83030424464815,
		RightLeg = 121417048354039,
	},
	{
		Name = "Pibble",
		Head = 101811223653042,
		Torso = 89452559495614,
		LeftArm = 104577190413171,
		RightArm = 101316380647934,
		LeftLeg = 109127286138167,
		RightLeg = 92492871789296,
	},
	{
		Name = "Alien Dog Pibble",
		Head = 134590341393939,
		Torso = 76983374560559,
		LeftArm = 128305706387064,
		RightArm = 90168108334852,
		LeftLeg = 73095711640635,
		RightLeg = 88073932856972,
	},
}




-- Game variables
local currentChaser = nil
local currentGameMode = "Role Swap"
local allChasers = {}
local playerUsedSkins = {}
local playerOriginalDescriptions = {}
local playerReadyStatus = {}
local playerSpeedBoostActive = {}
local gameStarted = false
local tagCooldown = false
local eliminationCooldowns = {} -- NEW: Track who was recently eliminated
local NORMAL_SPEED = 16
local CHASER_SPEED = NORMAL_SPEED * 1.3
local SPEED_BOOST_MULTIPLIER = 1.7
local SPEED_BOOST_DURATION = 1
local FREEZE_TIME = 5
local TAG_COOLDOWN_TIME = 4
local NORMAL_SCALE = 1
local CHASER_SCALE = 1.25


-- NEW: Function to get current chaser name(s) - ALWAYS accurate
local function getCurrentChaserNames()
	if GameModes.AllowsMultipleChasers(currentGameMode) then
		if #allChasers == 0 then
			return "None"
		end
		local names = {}
		for _, chaser in ipairs(allChasers) do
			if chaser and chaser.Parent then -- Verify player still exists
				table.insert(names, chaser.Name)
			end
		end
		return #names > 0 and table.concat(names, ", ") or "None"
	else
		if currentChaser and currentChaser.Parent then
			return currentChaser.Name
		end
		return "None"
	end
end

-- Function to check if player is ready
local function isPlayerReady(player)
	return playerReadyStatus[player.UserId] == true
end

-- Function to check if player is a chaser (uses GameModes module)
local function isChaser(player)
	if GameModes.AllowsMultipleChasers(currentGameMode) then
		-- Multi-chaser modes (Infection, etc.)
		return table.find(allChasers, player) ~= nil
	else
		-- Single-chaser modes (Role Swap, etc.)
		return player == currentChaser
	end
end

-- ===== CREATE A BINDABLE FUNCTION FOR CHASER CHECK =====
-- Add this after ReplicatedStorage RemoteEvents are created
local isChaserFunc = ReplicatedStorage:FindFirstChild("IsChaser")
if not isChaserFunc then
	isChaserFunc = Instance.new("BindableFunction")
	isChaserFunc.Name = "IsChaser"
	isChaserFunc.Parent = ReplicatedStorage
end

isChaserFunc.OnInvoke = function(player)
	return isChaser(player)
end

-- Function to teleport player to a spawn point with retry logic
local function teleportToSpawn(player, spawnLocation, maxRetries)
	maxRetries = maxRetries or 5

	if not player or not spawnLocation then 
		warn("‚ö†Ô∏è Invalid teleport parameters!")
		return false
	end

	for attempt = 1, maxRetries do
		if not player.Character then 
			warn("‚ö†Ô∏è " .. player.Name .. " has no character (attempt " .. attempt .. "/" .. maxRetries .. ")")
			task.wait(0.5)
			continue
		end

		local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
		if not humanoidRootPart then
			warn("‚ö†Ô∏è " .. player.Name .. " missing HumanoidRootPart (attempt " .. attempt .. "/" .. maxRetries .. ")")
			task.wait(0.5)
			continue
		end

		-- Teleport
		humanoidRootPart.CFrame = spawnLocation.CFrame + Vector3.new(0, 3, 0)
		task.wait(0.2)

		-- Verify teleport worked
		local distance = (humanoidRootPart.Position - spawnLocation.Position).Magnitude
		if distance < 20 then
			print("‚úÖ Teleported " .. player.Name .. " to " .. spawnLocation.Name .. " (attempt " .. attempt .. ")")
			return true
		else
			warn("‚ö†Ô∏è Teleport verification failed for " .. player.Name .. " (distance: " .. math.floor(distance) .. ") - retrying...")
			task.wait(0.3)
		end
	end

	warn("‚ùå Failed to teleport " .. player.Name .. " after " .. maxRetries .. " attempts!")
	return false
end

-- Listen for game mode updates from GameManager
local updateGameModeEvent = ReplicatedStorage:WaitForChild("UpdateGameMode", 10)
if updateGameModeEvent then
	updateGameModeEvent.OnServerEvent:Connect(function(mode)
		currentGameMode = mode
		print("üéÆ MainLogic received game mode: " .. mode)
	end)
end

-- Create a BindableEvent for GameManager to communicate game mode to MainLogic
local gameModeComm = ReplicatedStorage:FindFirstChild("GameModeUpdate")
if not gameModeComm then
	gameModeComm = Instance.new("BindableEvent")
	gameModeComm.Name = "GameModeUpdate"
	gameModeComm.Parent = ReplicatedStorage
end

gameModeComm.Event:Connect(function(mode)
	currentGameMode = mode
	print("üéÆ MainLogic: Game mode updated to " .. mode)
end)

-- Function to teleport all players to lobby with retry
local function teleportAllToLobby()
	local teleportedCount = 0
	local failedPlayers = {}

	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character then
			local success = teleportToSpawn(player, LobbySpawn, 5)
			if success then
				teleportedCount = teleportedCount + 1
			else
				table.insert(failedPlayers, player.Name)
			end
		end
	end

	print("üè† Teleported " .. teleportedCount .. " players to Lobby")

	-- Retry failed teleports one more time
	if #failedPlayers > 0 then
		warn("‚ö†Ô∏è Retrying failed teleports for: " .. table.concat(failedPlayers, ", "))
		task.wait(0.5)

		for _, player in ipairs(Players:GetPlayers()) do
			if table.find(failedPlayers, player.Name) and player.Character then
				teleportToSpawn(player, LobbySpawn, 3)
			end
		end
	end
end



local function chooseRandomMap()
	local maps = { "Map2"}
	currentMap = maps[math.random(1, #maps)]
	print("üó∫Ô∏è Selected map: " .. currentMap)

	-- Initialize Map2 escape system if Map2 is selected
	if currentMap == "Map2" then
		local success = Map2EscapeSystem.Initialize()
		if success then
			print("‚úÖ Map2 Escape System activated!")
		else
			warn("‚ö†Ô∏è Map2 Escape System failed to initialize!")
		end
	end

	return currentMap
end


-- Function to teleport players to game spawns with retry logic
local function teleportToGameSpawns()
	if not currentMap then return end

	local chaserSpawn, survivorSpawn

	if currentMap == "Map1" then
		chaserSpawn = Map1K
		survivorSpawn = Map1S
	elseif currentMap == "Map2" then
		chaserSpawn = Map2K
		survivorSpawn = Map2S
	elseif currentMap == "Map3" then
		chaserSpawn = Map3K
		survivorSpawn = Map3S
	end

	-- Teleport all players with verification
	for _, player in ipairs(Players:GetPlayers()) do
		-- Wait for character to load if missing
		if not player.Character then
			warn("‚ö†Ô∏è " .. player.Name .. " has no character during teleport! Waiting...")
			local success = false
			for i = 1, 10 do
				task.wait(0.5)
				if player.Character then
					success = true
					break
				end
			end

			if not success then
				warn("‚ùå " .. player.Name .. " character never loaded! Skipping...")
				continue
			end
		end

		-- Wait for critical components
		local humanoid = player.Character:WaitForChild("Humanoid", 5)
		local hrp = player.Character:WaitForChild("HumanoidRootPart", 5)

		if not humanoid or not hrp then
			warn("‚ö†Ô∏è " .. player.Name .. " character not fully loaded! Skipping teleport...")
			continue
		end

		-- Teleport with retry
		local targetSpawn = isChaser(player) and chaserSpawn or survivorSpawn
		local success = teleportToSpawn(player, targetSpawn, 5)

		if not success then
			warn("‚ùå Failed to teleport " .. player.Name .. " after all retries!")
		end
	end

	print("üéÆ Players spawned for " .. currentMap)
end

-- Function to get next available skin
local function getNextSkin(player)
	local usedSkins = playerUsedSkins[player.UserId] or {}

	if #usedSkins >= #PIBBLE_SKINS then
		usedSkins = {}
		playerUsedSkins[player.UserId] = usedSkins
		print(player.Name .. " has cycled through all skins! Resetting.")
	end

	local availableSkins = {}
	for i = 1, #PIBBLE_SKINS do
		local alreadyUsed = false
		for _, usedIndex in ipairs(usedSkins) do
			if usedIndex == i then
				alreadyUsed = true
				break
			end
		end

		if not alreadyUsed then
			table.insert(availableSkins, i)
		end
	end

	local randomIndex = availableSkins[math.random(1, #availableSkins)]
	table.insert(usedSkins, randomIndex)
	playerUsedSkins[player.UserId] = usedSkins

	return PIBBLE_SKINS[randomIndex]
end

-- Function to save player's original avatar
local function saveOriginalAvatar(player, character)
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid then return end

	local description = humanoid:GetAppliedDescription()
	playerOriginalDescriptions[player.UserId] = description
	print("Saved original avatar for " .. player.Name)
end

-- Function to restore player's original avatar
local function restoreOriginalAvatar(player, character)
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid then return end

	local originalDescription = playerOriginalDescriptions[player.UserId]
	if originalDescription then
		humanoid:ApplyDescription(originalDescription)
		print("Restored original avatar for " .. player.Name)
	end
end

-- Function to apply skin to player
local function applySkin(player, character, skin)
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid then return end

	local description = Instance.new("HumanoidDescription")
	description.Head = skin.Head
	description.Torso = skin.Torso
	description.LeftArm = skin.LeftArm
	description.RightArm = skin.RightArm
	description.LeftLeg = skin.LeftLeg
	description.RightLeg = skin.RightLeg

	humanoid:ApplyDescription(description)
end

-- Function to set character scale
local function setCharacterScale(character, scale)
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid then return end

	humanoid.HeadScale.Value = scale
	humanoid.BodyDepthScale.Value = scale
	humanoid.BodyHeightScale.Value = scale
	humanoid.BodyWidthScale.Value = scale
end

-- Function to create red light on chaser
local function createRedLight(character)
	local oldLight = character:FindFirstChild("ChaserLight")
	if oldLight then oldLight:Destroy() end

	local light = Instance.new("PointLight")
	light.Name = "ChaserLight"
	light.Color = Color3.fromRGB(255, 0, 0)
	light.Brightness = 2
	light.Range = 20
	light.Parent = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso")
end

-- Function to create nameplate with 30 stud range
local function createNameplate(character, isFreezed)
	local oldPlate = character:FindFirstChild("ChaserNameplate")
	if oldPlate then oldPlate:Destroy() end

	local head = character:FindFirstChild("Head")
	if not head then return end

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "ChaserNameplate"
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.StudsOffset = Vector3.new(0, 3, 0)
	billboard.AlwaysOnTop = true
	billboard.MaxDistance = 30
	billboard.Parent = head

	local textLabel = Instance.new("TextLabel")
	textLabel.Name = "TextLabel"
	textLabel.Size = UDim2.new(1, 0, 1, 0)
	textLabel.BackgroundTransparency = 1
	textLabel.Text = isFreezed and ("Freezed " .. FREEZE_TIME) or "Pibble üòà"
	textLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
	textLabel.TextScaled = true
	textLabel.Font = Enum.Font.GothamBold
	textLabel.TextStrokeTransparency = 0.5
	textLabel.Parent = billboard
end

-- Function to run freeze countdown on nameplate
local function runFreezeCountdown(character)
	for countdown = FREEZE_TIME, 1, -1 do
		task.wait(1)

		local head = character:FindFirstChild("Head")
		if head then
			local nameplate = head:FindFirstChild("ChaserNameplate")
			if nameplate then
				local textLabel = nameplate:FindFirstChild("TextLabel")
				if textLabel then
					if countdown > 1 then
						textLabel.Text = "Freezed " .. (countdown - 1)
					else
						textLabel.Text = "Pibble üòà"
					end
				end
			end
		end
	end
end

-- Function to remove ALL chaser effects
local function removeEffects(character)
	local light = character:FindFirstChild("ChaserLight")
	if light then 
		light:Destroy()
		print("Removed red light from " .. character.Name)
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if hrp then
		local hrpLight = hrp:FindFirstChild("ChaserLight")
		if hrpLight then hrpLight:Destroy() end
	end

	local torso = character:FindFirstChild("Torso")
	if torso then
		local torsoLight = torso:FindFirstChild("ChaserLight")
		if torsoLight then torsoLight:Destroy() end
	end

	local nameplate = character:FindFirstChild("ChaserNameplate")
	if nameplate then nameplate:Destroy() end

	setCharacterScale(character, NORMAL_SCALE)
end

-- Function to apply speed boost to ex-chaser
local function applySpeedBoost(player)
	if not player.Character then return end

	local humanoid = player.Character:FindFirstChild("Humanoid")
	if not humanoid then return end

	playerSpeedBoostActive[player.UserId] = true

	local boostedSpeed = NORMAL_SPEED * SPEED_BOOST_MULTIPLIER
	humanoid.WalkSpeed = boostedSpeed

	print("‚ö° " .. player.Name .. " got speed boost! Speed: " .. boostedSpeed .. " for " .. SPEED_BOOST_DURATION .. " seconds")

	local soundEvent = ReplicatedStorage:FindFirstChild("PlayTagSoundServer")
	if soundEvent and player.Character:FindFirstChild("HumanoidRootPart") then
		soundEvent:Fire(player.Character.HumanoidRootPart.Position, "speedboost")
	end

	task.delay(SPEED_BOOST_DURATION, function()
		if humanoid and humanoid.Parent and not isChaser(player) then
			humanoid.WalkSpeed = NORMAL_SPEED
			playerSpeedBoostActive[player.UserId] = false
			print("‚è±Ô∏è " .. player.Name .. "'s speed boost expired")
		end
	end)
end

-- Function to transfer all tools from victim to chaser
local function transferItemsToChaser(victim, chaser)
	if not victim or not chaser then return end

	print("üì¶ Transferring items from " .. victim.Name .. " to " .. chaser.Name)

	local victimBackpack = victim:FindFirstChild("Backpack")
	local victimCharacter = victim.Character
	local chaserBackpack = chaser:FindFirstChild("Backpack")

	if not chaserBackpack then 
		warn("‚ö†Ô∏è Chaser has no backpack!")
		return 
	end

	local itemsTransferred = 0

	if victimBackpack then
		for _, tool in ipairs(victimBackpack:GetChildren()) do
			if tool:IsA("Tool") then
				local toolClone = tool:Clone()
				toolClone.Parent = chaserBackpack
				tool:Destroy()
				itemsTransferred = itemsTransferred + 1
				print("  ‚úÖ Transferred: " .. tool.Name)
			end
		end
	end

	if victimCharacter then
		for _, tool in ipairs(victimCharacter:GetChildren()) do
			if tool:IsA("Tool") then
				local toolClone = tool:Clone()
				toolClone.Parent = chaserBackpack
				tool:Destroy()
				itemsTransferred = itemsTransferred + 1
				print("  ‚úÖ Transferred equipped: " .. tool.Name)
			end
		end
	end

	print("üì¶ Transferred " .. itemsTransferred .. " item(s) to " .. chaser.Name)
end

-- Fixed endGame() function with proper cleanup order
local function endGame()
	if not gameStarted then 
		print("‚ö†Ô∏è endGame called but gameStarted is already false")
		return 
	end

	print("=== STARTING GAME END SEQUENCE ===")

	gameStarted = false
	tagCooldown = false
	ChaserAbilities.SetGameActive(false)

	-- STEP 1: Reset Map2 escape system FIRST (with error protection)
	if currentMap == "Map2" then
		local success, err = pcall(function()
			Map2EscapeSystem.Reset()
		end)
		if not success then
			warn("‚ö†Ô∏è Map2EscapeSystem.Reset() error (non-critical): " .. tostring(err))
		end
	end

	print("=== GAME ENDED ===")
	print("Tagging is now DISABLED!")

	local previousMode = currentGameMode

	-- Determine winner
	local winner = "Survivors Win! üéâ"

	if currentGameMode == "Survival" then
		local readyPlayers = {}
		for _, player in ipairs(Players:GetPlayers()) do
			if isPlayerReady(player) and player.Character then
				table.insert(readyPlayers, player)
			end
		end

		local survivorsInGame = 0
		local totalSurvivors = 0
		local escapedCount = Map2EscapeSystem.GetEscapedCount()

		for _, player in ipairs(readyPlayers) do
			if not isChaser(player) then
				totalSurvivors = totalSurvivors + 1

				-- Only count as "in game" if not escaped and not in lobby
				if not Map2EscapeSystem.HasPlayerEscaped(player) then
					local hrp = player.Character:FindFirstChild("HumanoidRootPart")
					if hrp then
						local distanceFromLobby = (hrp.Position - LobbySpawn.Position).Magnitude
						if distanceFromLobby > 50 then
							survivorsInGame = survivorsInGame + 1
						end
					end
				end
			end
		end

		-- If no survivors in game, check if they escaped or were eliminated
		if survivorsInGame == 0 and totalSurvivors > 0 then
			if escapedCount >= totalSurvivors then
				winner = "Survivors Escaped! üéâ‚úàÔ∏è"
			else
				winner = "Chaser Wins! üòà"
			end
		elseif survivorsInGame > 0 then
			-- Timer ran out with survivors still alive
			winner = "Survivors Survived! üéâ"
		end
	elseif GameModes.AllowsMultipleChasers(currentGameMode) then
		local readyPlayers = {}
		for _, player in ipairs(Players:GetPlayers()) do
			if isPlayerReady(player) and player.Character then
				table.insert(readyPlayers, player)
			end
		end

		if #allChasers >= #readyPlayers then
			winner = "Chasers Win! ü¶†"
		end
	end
	-- Get chaser name(s) BEFORE clearing (for round end display)
	local chaserNames = getCurrentChaserNames()
	print("üèÅ Round ending with chaser(s): " .. chaserNames)
	
	-- ‚úÖ STEP 2: Show round end GUI FIRST (before any cleanup)
	local roundEndEvent = ReplicatedStorage:FindFirstChild("RoundEnd")
	if roundEndEvent then
		roundEndEvent:FireAllClients({
			winner = winner,
			chaser = chaserNames,
			gameMode = currentGameMode
		})
		print("üèÅ Round end screen sent to all clients!")
		print("üèÜ Winner: " .. winner)
	else
		warn("‚ö†Ô∏è RoundEnd RemoteEvent not found!")
	end
	
	-- ‚úÖ STEP 2.5: Fire server-side round end for other systems (Chest & Door, etc.)
	local serverRoundEnd = ReplicatedStorage:FindFirstChild("ServerRoundEnd")
	if not serverRoundEnd then
		serverRoundEnd = Instance.new("BindableEvent")
		serverRoundEnd.Name = "ServerRoundEnd"
		serverRoundEnd.Parent = ReplicatedStorage
		print("‚úÖ Created ServerRoundEnd BindableEvent")
	end
	if serverRoundEnd:IsA("BindableEvent") then
		print("üì° Firing ServerRoundEnd event...")
		serverRoundEnd:Fire()
		print("üì° Server-side round end signal sent (ServerRoundEnd)")
	end
	
	-- ‚úÖ STEP 3: Wait for GUI to fully appear and cover screen
	print("‚è∏Ô∏è Waiting 1 second for GUI to cover screen...")
	task.wait(1)

	-- ‚úÖ STEP 4: Teleport everyone to lobby (while GUI is showing)
	print("üè† Teleporting all players to lobby (GUI still visible)...")
	teleportAllToLobby()

	-- ‚úÖ STEP 5: Clean up ALL players (critical fix - do this BEFORE waiting)
	print("üîÑ Cleaning up ALL players (GUI still visible)...")
	for _, player in ipairs(Players:GetPlayers()) do
		task.spawn(function()
			if player.Character then
				-- Clean up effects
				removeEffects(player.Character)

				-- Restore avatar (critical!)
				restoreOriginalAvatar(player, player.Character)

				-- Clear abilities and guns
				ChaserAbilities.ClearAbilities(player)
				GunSystem.RemoveGun(player)

				-- If on Map2, explicitly remove Key tool
				if currentMap == "Map2" then
					-- Check backpack
					local backpack = player:FindFirstChild("Backpack")
					if backpack then
						local keyTool = backpack:FindFirstChild("Key")
						if keyTool then
							keyTool:Destroy()
							print("üóëÔ∏è MainLogic: Removed Key from " .. player.Name .. "'s backpack")
						end
					end

					-- Check character
					local keyInChar = player.Character:FindFirstChild("Key")
					if keyInChar then
						keyInChar:Destroy()
						print("üóëÔ∏è MainLogic: Removed Key from " .. player.Name .. "'s character")
					end
				end

				-- Reset speed
				local humanoid = player.Character:FindFirstChild("Humanoid")
				if humanoid then
					humanoid.WalkSpeed = NORMAL_SPEED
				end

				playerSpeedBoostActive[player.UserId] = false

				-- Re-enable animations
				AnimationHandler.EnableCustomAnimations(player)

				print("üßπ Cleaned up " .. player.Name)
			end
		end)
	end

	-- Wait for all cleanups to complete
	task.wait(0.5)

	-- ‚úÖ STEP 6: Double-check avatars are restored
	print("üîÑ Double-checking all avatars restored...")
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character then
			restoreOriginalAvatar(player, player.Character)

			-- Verify position
			if player.Character:FindFirstChild("HumanoidRootPart") then
				local hrp = player.Character.HumanoidRootPart
				local distanceFromLobby = (hrp.Position - LobbySpawn.Position).Magnitude

				if distanceFromLobby > 50 then
					warn("üîß " .. player.Name .. " not at lobby, re-teleporting...")
					teleportToSpawn(player, LobbySpawn, 3)
				end
			end

			print("‚úÖ Verified cleanup for " .. player.Name)
		end
	end

	-- ‚úÖ STEP 7: Reset game state variables and notify clients
	ChaserAbilities.SetCurrentChaser(nil)
	GunSystem.SetCurrentChaser(nil)
	currentChaser = nil
	allChasers = {}
	eliminationCooldowns = {}

	-- Notify clients that there's no chaser now
	updateChaserEvent:FireAllClients("None")
	print("üì° Clients notified: No current chaser (round ended)")

	currentGameMode = "Role Swap"

	print("‚úÖ Game cleanup complete (" .. previousMode .. " mode ended)")

	-- ‚úÖ STEP 8: Wait for rest of GUI duration
	print("‚è∏Ô∏è Waiting 5 more seconds for GUI to finish (total: 6s)...")
	task.wait(5)

	-- ‚úÖ STEP 9: Tell GameManager game ended
	local serverComm = ReplicatedStorage:FindFirstChild("ServerGameState")
	if serverComm then
		print("üì° Notifying GameManager that game ended...")
		serverComm:Fire("end")
	else
		warn("‚ùå Could not notify GameManager - ServerGameState not found!")
	end

	print("‚úÖ All players in lobby - ready for next round!")
end


local function checkInfectionWinCondition()
	local readyPlayers = {}
	for _, player in ipairs(Players:GetPlayers()) do
		if isPlayerReady(player) and player.Character then
			table.insert(readyPlayers, player)
		end
	end

	local survivorCount = 0
	local escapedCount = Map2EscapeSystem.GetEscapedCount()

	for _, player in ipairs(readyPlayers) do
		if not isChaser(player) then
			-- Only count as survivor if they haven't escaped AND aren't in lobby
			if not Map2EscapeSystem.HasPlayerEscaped(player) then
				local hrp = player.Character:FindFirstChild("HumanoidRootPart")
				if hrp then
					local distanceFromLobby = (hrp.Position - LobbySpawn.Position).Magnitude
					if distanceFromLobby > 50 then
						survivorCount = survivorCount + 1
					end
				end
			end
		end
	end

	print("ü¶† Infection check: " .. survivorCount .. " survivor(s) remaining, " .. escapedCount .. " escaped")

	-- WIN CONDITION: No survivors left (everyone infected or escaped)
	-- Check if there are enough chasers (at least 2 players total, meaning infection happened)
	if survivorCount == 0 and #readyPlayers >= 2 then
		-- Count total non-chaser players (initial survivors)
		local totalSurvivors = #readyPlayers - 1  -- Minus initial chaser

		-- Check if survivors escaped (survivors win!)
		if escapedCount >= totalSurvivors then
			print("‚úàÔ∏è ALL SURVIVORS ESCAPED! SURVIVORS WIN!")

			local updateStatusEvent = ReplicatedStorage:FindFirstChild("UpdateStatus")
			if updateStatusEvent then
				updateStatusEvent:FireAllClients("‚úàÔ∏è ALL SURVIVORS ESCAPED! SURVIVORS WIN! üéâ", false)
			end

			task.delay(2, function()
				if gameStarted then
					endGame()
				end
			end)

			return true
		else
			-- Everyone is infected - chasers win!
			print("ü¶† CHASERS WIN! All players infected!")

			local updateStatusEvent = ReplicatedStorage:FindFirstChild("UpdateStatus")
			if updateStatusEvent then
				updateStatusEvent:FireAllClients(GameModes.GetWinMessage(currentGameMode, "chasers"), false)
			end

			task.delay(2, function()
				if gameStarted then
					endGame()
				end
			end)

			return true
		end
	elseif survivorCount == 1 then
		-- One survivor left - game continues
		return false
	end

	return false
end

-- Fixed checkSurvivalWinCondition - IMMEDIATELY ends game properly
local function checkSurvivalWinCondition()
	-- Only check in Survival mode
	if currentGameMode ~= "Survival" then return false end

	local readyPlayers = {}
	for _, player in ipairs(Players:GetPlayers()) do
		if isPlayerReady(player) and player.Character then
			table.insert(readyPlayers, player)
		end
	end

	-- Count how many survivors are still in the game (not in lobby AND not escaped)
	local survivorsInGame = 0
	local totalSurvivors = 0 -- Total non-chaser players

	for _, player in ipairs(readyPlayers) do
		if not isChaser(player) then
			totalSurvivors = totalSurvivors + 1

			-- Check if they escaped via helicopter
			if Map2EscapeSystem.HasPlayerEscaped(player) then
				print("   ‚úàÔ∏è " .. player.Name .. " has escaped (not counted as eliminated)")
				-- Don't count as in-game, but also not eliminated
			else
				-- Check if they're still in the map (not in lobby)
				local hrp = player.Character:FindFirstChild("HumanoidRootPart")
				if hrp then
					local distanceFromLobby = (hrp.Position - LobbySpawn.Position).Magnitude
					if distanceFromLobby > 50 then
						survivorsInGame = survivorsInGame + 1
					end
				end
			end
		end
	end

	local escapedCount = Map2EscapeSystem.GetEscapedCount()
	print("üèÜ Survival check: " .. survivorsInGame .. " survivor(s) in game, " .. escapedCount .. " escaped")

	-- WIN CONDITION: All survivors either eliminated OR escaped
	if survivorsInGame == 0 and totalSurvivors > 0 then
		-- Check if ALL survivors escaped (survivors win!)
		if escapedCount >= totalSurvivors then
			print("‚úàÔ∏è ALL SURVIVORS ESCAPED! SURVIVORS WIN!")

			-- Show victory message immediately
			local updateStatusEvent = ReplicatedStorage:FindFirstChild("UpdateStatus")
			if updateStatusEvent then
				updateStatusEvent:FireAllClients("‚úàÔ∏è ALL SURVIVORS ESCAPED! SURVIVORS WIN! üéâ", false)
			end

			-- Wait 2 seconds to show message, THEN call endGame
			task.delay(2, function()
				if gameStarted then
					endGame()
				end
			end)

			return true
		else
			-- Some escaped, but not all - remaining were eliminated (chaser wins)
			print("üòà CHASER WINS! All non-escaped survivors eliminated!")

			-- Show victory message immediately
			local updateStatusEvent = ReplicatedStorage:FindFirstChild("UpdateStatus")
			if updateStatusEvent then
				updateStatusEvent:FireAllClients("üòà ALL SURVIVORS ELIMINATED! CHASER WINS! üòà", false)
			end

			-- Wait 2 seconds to show message, THEN call endGame
			task.delay(2, function()
				if gameStarted then
					endGame()
				end
			end)

			return true
		end
	end

	return false
end


-- ===== ADD NEW WIN CONDITION CHECK FUNCTION =====
-- Add this new function anywhere in MainLogic:
-- Find this function in your MainLogic (around line 820):
-- Replace the checkMap2EscapeWinCondition function in MainLogic with this:

-- IMPROVED makeChaser with better freeze handling
local function makeChaser(player, shouldFreeze)
	if not player.Character then 
		warn("‚ö†Ô∏è Cannot make " .. player.Name .. " chaser - no character!")
		error("No character") -- Throw error so pcall catches it
	end

	-- Wait for character components with timeout
	local loadTimeout = 10
	local loadStart = tick()

	while (not player.Character:FindFirstChild("Humanoid") or not player.Character:FindFirstChild("HumanoidRootPart")) and (tick() - loadStart < loadTimeout) do
		task.wait(0.1)
	end

	local humanoid = player.Character:FindFirstChild("Humanoid")
	local hrp = player.Character:FindFirstChild("HumanoidRootPart")

	if not humanoid or not hrp then
		warn("‚ö†Ô∏è Cannot make " .. player.Name .. " chaser - character not fully loaded!")
		error("Character not loaded") -- Throw error
	end

	-- Set chaser in game mode logic
	if GameModes.AllowsMultipleChasers(currentGameMode) then
		-- FIXED: Add to allChasers instead of replacing
		if not table.find(allChasers, player) then
			table.insert(allChasers, player)
			print("ü¶† " .. player.Name .. " is now infected! Total: " .. #allChasers)
		end
		-- Set as current chaser for this specific makeChaser call
		currentChaser = player
	else
		local oldChaser = currentChaser

		if oldChaser and oldChaser.Character and oldChaser ~= player then
			removeEffects(oldChaser.Character)
			ChaserAbilities.ClearAbilities(oldChaser)

			local humanoid = oldChaser.Character:FindFirstChild("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = NORMAL_SPEED
			end

			restoreOriginalAvatar(oldChaser, oldChaser.Character)
			updateSkinEvent:FireClient(oldChaser, "Normal Avatar")

			AnimationHandler.EnableCustomAnimations(oldChaser)

			if GameModes.ShouldGiveSpeedBoost(currentGameMode) then
				applySpeedBoost(oldChaser)
				print(oldChaser.Name .. " lost chaser status - speed boost applied!")
			else
				print(oldChaser.Name .. " lost chaser status!")
			end
		end

		-- Single-chaser mode: replace the chaser
		currentChaser = player
		allChasers = {player}

		-- Notify door system
		local chaserUpdateEvent = ReplicatedStorage:FindFirstChild("ChaserUpdate")
		if chaserUpdateEvent then
			chaserUpdateEvent:Fire(currentChaser, allChasers)
			print("üì° Notified door system: " .. player.Name .. " is chaser")
		end	
	end

	-- Set chaser BEFORE applying effects
	ChaserAbilities.SetCurrentChaser(player)
	GunSystem.SetCurrentChaser(player)

	-- Update clients immediately with accurate chaser info
	local chaserNames = getCurrentChaserNames()
	updateChaserEvent:FireAllClients(chaserNames)
	print("üì° Clients notified: Current Pibble(s) = " .. chaserNames)

	local character = player.Character

	-- Cancel speed boost
	playerSpeedBoostActive[player.UserId] = false

	-- IMPROVED FREEZE LOGIC
	if shouldFreeze and humanoid then
		print("‚ùÑÔ∏è Freezing " .. player.Name .. " for " .. FREEZE_TIME .. " seconds...")

		-- Set frozen status FIRST
		ChaserAbilities.SetPlayerFrozen(player, true)

		-- Tell client they're frozen (CRITICAL for stamina system)
		local updateFreezeEvent = ReplicatedStorage:FindFirstChild("UpdateFreezeStatus")
		if not updateFreezeEvent then
			updateFreezeEvent = Instance.new("RemoteEvent")
			updateFreezeEvent.Name = "UpdateFreezeStatus"
			updateFreezeEvent.Parent = ReplicatedStorage
		end
		updateFreezeEvent:FireClient(player, true)

		-- Initial freeze
		humanoid.WalkSpeed = 0
		humanoid.JumpPower = 0

		-- CRITICAL: Continuously enforce freeze every frame on SERVER
		local RunService = game:GetService("RunService")
		local freezeConnection
		local freezeEndTime = tick() + FREEZE_TIME

		freezeConnection = RunService.Heartbeat:Connect(function()
			if tick() >= freezeEndTime then
				freezeConnection:Disconnect()

				-- UNFREEZE
				print("üî• Unfreezing " .. player.Name)
				ChaserAbilities.SetPlayerFrozen(player, false)

				if updateFreezeEvent then
					updateFreezeEvent:FireClient(player, false)
				end

				if humanoid and humanoid.Parent then
					humanoid.WalkSpeed = CHASER_SPEED
					humanoid.JumpPower = 50
					print("‚úÖ " .. player.Name .. " unfrozen and ready!")
				end
			else
				-- Keep enforcing freeze every frame (SERVER-SIDE)
				if humanoid and humanoid.Parent and player.Character then
					humanoid.WalkSpeed = 0
					humanoid.JumpPower = 0
				else
					freezeConnection:Disconnect()
				end
			end
		end)
	else
		-- No freeze - set speed immediately
		if humanoid then
			humanoid.WalkSpeed = CHASER_SPEED
			humanoid.JumpPower = 50
		end
	end

	-- Apply visual effects
	local newSkin = getNextSkin(player)
	applySkin(player, character, newSkin)

	local usedCount = #(playerUsedSkins[player.UserId] or {})
	print(player.Name .. " is chaser - skin: " .. newSkin.Name .. " (" .. usedCount .. "/" .. #PIBBLE_SKINS .. ")")

	createRedLight(character)
	createNameplate(character, shouldFreeze)
	setCharacterScale(character, CHASER_SCALE)

	AnimationHandler.DisableCustomAnimations(player)

	-- Run freeze countdown
	if shouldFreeze then
		coroutine.wrap(function()
			runFreezeCountdown(character)
		end)()
	end

	updateSkinEvent:FireClient(player, newSkin.Name)

	print("‚úÖ makeChaser completed for " .. player.Name)
end

-- FIXED onTouch function with better error handling
local function onTouch(hit, chaserCharacter)
	if not gameStarted then 
		print("üö´ Tag blocked: Game not started")
		return 
	end

	if tagCooldown then 
		print("üö´ Tag blocked: Cooldown active")
		return 
	end

	local touchingPlayer = Players:GetPlayerFromCharacter(chaserCharacter)
	if not touchingPlayer or not isChaser(touchingPlayer) then
		return
	end

	-- Check if chaser is frozen (CRITICAL FIX)
	if ChaserAbilities.IsPlayerFrozen(touchingPlayer) then
		print("‚ùÑÔ∏è Tag blocked: Chaser " .. touchingPlayer.Name .. " is frozen!")
		return
	end

	local humanoid = hit.Parent:FindFirstChild("Humanoid")
	if not humanoid then return end

	local player = Players:GetPlayerFromCharacter(hit.Parent)
	if not player then 
		return 
	end

	if isChaser(player) then 
		print("üö´ Tag blocked: Target is already chaser")
		return 
	end

	-- FIXED: Check elimination cooldown only for Survival mode
	if GameModes.SendsToLobbyOnTag(currentGameMode) and eliminationCooldowns[player.UserId] then
		print("üö´ Tag blocked: " .. player.Name .. " recently eliminated")
		return
	end

	print("‚úÖ " .. touchingPlayer.Name .. " tagged " .. player.Name .. "!")

	-- Check if this mode sends tagged players to lobby
	if GameModes.SendsToLobbyOnTag(currentGameMode) then
		-- Survival mode elimination logic...
		eliminationCooldowns[player.UserId] = true

		local tagPosition = player.Character.HumanoidRootPart.Position
		local soundEvent = ReplicatedStorage:FindFirstChild("PlayTagSoundServer")
		if soundEvent then
			soundEvent:Fire(tagPosition, "attack")
		end

		GunSystem.RemoveGun(player)

		local humanoid = player.Character:FindFirstChild("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = 0
			humanoid.JumpPower = 0
		end

		-- Create elimination billboard...
		local head = player.Character:FindFirstChild("Head")
		if head then
			local oldBillboard = head:FindFirstChild("EliminatedBillboard")
			if oldBillboard then oldBillboard:Destroy() end

			local billboard = Instance.new("BillboardGui")
			billboard.Name = "EliminatedBillboard"
			billboard.Size = UDim2.new(0, 200, 0, 60)
			billboard.StudsOffset = Vector3.new(0, 3, 0)
			billboard.AlwaysOnTop = true
			billboard.Parent = head

			local frame = Instance.new("Frame")
			frame.Size = UDim2.new(1, 0, 1, 0)
			frame.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
			frame.BorderSizePixel = 0
			frame.Parent = billboard

			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0.2, 0)
			corner.Parent = frame

			local stroke = Instance.new("UIStroke")
			stroke.Color = Color3.fromRGB(255, 255, 255)
			stroke.Thickness = 2
			stroke.Parent = frame

			local textLabel = Instance.new("TextLabel")
			textLabel.Size = UDim2.new(0.9, 0, 0.9, 0)
			textLabel.Position = UDim2.new(0.05, 0, 0.05, 0)
			textLabel.BackgroundTransparency = 1
			textLabel.Text = "ELIMINATED "
			textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			textLabel.TextScaled = true
			textLabel.Font = Enum.Font.GothamBlack
			textLabel.Parent = frame

			print("üíÄ Created elimination billboard for " .. player.Name)
		end

		local eliminationEvent = ReplicatedStorage:FindFirstChild("PlayerEliminated")
		if eliminationEvent then
			eliminationEvent:FireClient(player)
		end

		local updateStatusEvent = ReplicatedStorage:FindFirstChild("UpdateStatus")
		if updateStatusEvent then
			updateStatusEvent:FireAllClients("üíÄ " .. player.Name .. " was eliminated!", false)
		end

		task.wait(2)

		teleportToSpawn(player, LobbySpawn)

		if humanoid then
			humanoid.WalkSpeed = NORMAL_SPEED
			humanoid.JumpPower = 50
		end

		if head then
			local billboard = head:FindFirstChild("EliminatedBillboard")
			if billboard then
				billboard:Destroy()
			end
		end

		if player.Character then
			removeEffects(player.Character)
		end

		print("üè† " .. player.Name .. " teleported to lobby after elimination")

		task.delay(0.5, function()
			checkSurvivalWinCondition()
		end)

		-- FIXED: Shorter cooldown to minimize blocking window
		task.delay(0.5, function()
			eliminationCooldowns[player.UserId] = nil
			print("‚úÖ Elimination cooldown cleared for " .. player.Name)
		end)

		-- Set tag cooldown AFTER successful elimination
		tagCooldown = true
		print("‚è±Ô∏è Tag cooldown active for " .. TAG_COOLDOWN_TIME .. " seconds!")

		task.delay(TAG_COOLDOWN_TIME, function()
			tagCooldown = false
			print("‚úÖ Tag cooldown ended!")
		end)

		return
	end

	-- Role swap mode item transfer logic...
	if GameModes.ShouldTransferItems(currentGameMode) then
		print("üîÑ Role Swap mode - Transferring items and guns...")

		local oldChaserHadGun = false
		local newChaserHadGun = false

		local oldChaserBackpack = touchingPlayer:FindFirstChild("Backpack")
		local oldChaserCharacter = touchingPlayer.Character

		if oldChaserBackpack and oldChaserBackpack:FindFirstChild("Pibble Switch") then
			oldChaserHadGun = true
		end
		if oldChaserCharacter and oldChaserCharacter:FindFirstChild("Pibble Switch") then
			oldChaserHadGun = true
		end

		local newChaserBackpack = player:FindFirstChild("Backpack")
		local newChaserCharacter = player.Character

		if newChaserBackpack and newChaserBackpack:FindFirstChild("Pibble Switch") then
			newChaserHadGun = true
		end
		if newChaserCharacter and newChaserCharacter:FindFirstChild("Pibble Switch") then
			newChaserHadGun = true
		end

		print("üîç Before transfer:")
		print("   Old chaser (" .. touchingPlayer.Name .. ") had gun: " .. tostring(oldChaserHadGun))
		print("   New chaser (" .. player.Name .. ") had gun: " .. tostring(newChaserHadGun))

		transferItemsToChaser(player, touchingPlayer)

		task.delay(0.5, function()
			if player and player.Character then
				GunSystem.RemoveGun(player)
				print("üóëÔ∏è Removed gun from new chaser: " .. player.Name)
			end

			if touchingPlayer and touchingPlayer.Character then
				GunSystem.RemoveGun(touchingPlayer)
				task.wait(0.1)

				GunSystem.GiveGun(touchingPlayer)
				print("üî´ Gave fresh gun to ex-chaser (now survivor): " .. touchingPlayer.Name)
			end
		end)
	else
		print("ü¶† " .. currentGameMode .. " mode - No items transferred")
	end

	local tagPosition = player.Character.HumanoidRootPart.Position
	local soundEvent = ReplicatedStorage:FindFirstChild("PlayTagSoundServer")
	if soundEvent then
		soundEvent:Fire(tagPosition, "attack")
	end

	-- Set tag cooldown BEFORE makeChaser (in case it fails)
	tagCooldown = true
	print("‚è±Ô∏è Tag cooldown active for " .. TAG_COOLDOWN_TIME .. " seconds!")

	-- Attempt to make chaser
	local success = pcall(function()
		makeChaser(player, true)
	end)

	-- Check if makeChaser failed FIRST
	if not success then
		warn("‚ùå makeChaser failed! Resetting tag cooldown...")
		tagCooldown = false
		return
	end


	-- Check win condition for infection modes
	if GameModes.HasEarlyEndCondition(currentGameMode) then
		checkInfectionWinCondition()
	end

	-- Reset tag cooldown after delay
	task.delay(TAG_COOLDOWN_TIME, function()
		tagCooldown = false
		print("‚úÖ Tag cooldown ended!")
	end)
end



local function setupTouchDetection(character)
	task.spawn(function()
		local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 10)
		if not humanoidRootPart then
			warn("‚ö†Ô∏è Failed to setup touch detection for " .. character.Name .. " - no HumanoidRootPart")
			return
		end

		humanoidRootPart.Touched:Connect(function(hit)
			onTouch(hit, character)
		end)

		print("‚úÖ Touch detection setup for " .. character.Name)
	end)
end



-- FIXED startGame() - Shows GUI BEFORE teleporting
local function startGame()
	if gameStarted then return end

	local allPlayers = Players:GetPlayers()
	local readyPlayers = {}
	for _, player in ipairs(allPlayers) do
		if isPlayerReady(player) and player.Character then
			table.insert(readyPlayers, player)
		end
	end

	if #readyPlayers < 2 then
		print("Not enough ready players to start! Need at least 2 ready players.")
		return
	end

	gameStarted = true
	tagCooldown = true
	ChaserAbilities.SetGameActive(true)

	print("=== GAME STARTING WITH " .. #readyPlayers .. " READY PLAYERS ===")
	print("üéÆ MODE: " .. currentGameMode)

	chooseRandomMap()

	-- Select random chaser with validation
	local randomPlayer = nil
	local attempts = 0

	repeat
		attempts = attempts + 1
		randomPlayer = readyPlayers[math.random(1, #readyPlayers)]

		if not randomPlayer.Character then
			warn("‚ö†Ô∏è Selected chaser has no character! Waiting... (attempt " .. attempts .. ")")

			local waitStart = tick()
			while not randomPlayer.Character and (tick() - waitStart < 5) do
				task.wait(0.2)
			end
		end

		if randomPlayer.Character then
			local humanoid = randomPlayer.Character:FindFirstChild("Humanoid")
			local hrp = randomPlayer.Character:FindFirstChild("HumanoidRootPart")

			if humanoid and hrp then
				print("‚úÖ Valid chaser selected: " .. randomPlayer.Name)
				break
			end
		end

		warn("‚ö†Ô∏è Chaser validation failed, trying another player...")

	until attempts >= #readyPlayers * 2

	if not randomPlayer or not randomPlayer.Character then
		warn("‚ùå Could not find valid chaser! Aborting game start...")
		gameStarted = false
		tagCooldown = false
		return
	end

	allChasers = {randomPlayer}
	currentChaser = randomPlayer  -- Set this early!

	-- Immediately notify clients of the chaser BEFORE showing GUI
	updateChaserEvent:FireAllClients(randomPlayer.Name)
	print("üì° Pre-notified clients: " .. randomPlayer.Name .. " will be chaser")

	task.wait(0.1)  -- Small delay to ensure the update reaches clients first

	-- ‚úÖ STEP 1: Show round start GUI FIRST (before teleporting)
	local roundStartEvent = ReplicatedStorage:FindFirstChild("RoundStart")
	if roundStartEvent then
		roundStartEvent:FireAllClients({
			gameMode = currentGameMode,
			map = currentMap,
			chaser = randomPlayer.Name
		})
		print("üé¨ Round start GUI sent to all clients - showing NOW!")
	else
		warn("‚ö†Ô∏è RoundStart RemoteEvent not found! Creating it...")
		roundStartEvent = Instance.new("RemoteEvent")
		roundStartEvent.Name = "RoundStart"
		roundStartEvent.Parent = ReplicatedStorage

		roundStartEvent:FireAllClients({
			gameMode = currentGameMode,
			map = currentMap,
			chaser = randomPlayer.Name
		})
	end

	-- ‚úÖ STEP 2: Wait for GUI to fully appear (1 second)
	print("‚è∏Ô∏è Waiting 1 second for GUI to cover screen...")
	task.wait(1)

	-- ‚úÖ STEP 3: Make player the chaser (while GUI is showing)
	print("üëπ Making " .. randomPlayer.Name .. " the chaser...")
	makeChaser(randomPlayer, false)

	-- ‚úÖ STEP 4: Teleport everyone to game spawns (while GUI is still showing)
	print("üöÄ Teleporting players to " .. currentMap .. " (GUI still visible)...")
	wait(0.5)
	teleportToGameSpawns()

	-- ‚úÖ STEP 5: Give guns to survivors (while GUI is showing)
	task.delay(0.5, function()
		if GunSystem and typeof(GunSystem.GiveGunsToSurvivors) == "function" then
			local success, err = pcall(function()
				GunSystem.GiveGunsToSurvivors(Players:GetPlayers(), currentChaser)
			end)
			if success then
				print("üî´ Gave guns to survivors (" .. currentGameMode .. " mode)")
			else
				warn("‚ùå Error calling GiveGunsToSurvivors: " .. tostring(err))
				task.wait(0.5)
				pcall(function()
					GunSystem.GiveGunsToSurvivors(Players:GetPlayers(), currentChaser)
				end)
			end
		else
			warn("‚ùå GunSystem.GiveGunsToSurvivors is not available!")
		end
	end)

	-- ‚úÖ STEP 6: Wait for rest of GUI duration (3 more seconds = 4 total)
	print("‚è∏Ô∏è Waiting 3 more seconds for GUI to finish (total: 4s)...")
	task.wait(3)

	-- ‚úÖ STEP 7: Enable tagging (GUI should hide itself on client)
	if gameStarted then
		tagCooldown = false
		print("‚úÖ Round start GUI finished! Tagging is now ENABLED!")
		print("‚ñ∂Ô∏è Game timer starting NOW!")

		-- After tagging is enabled, check win conditions periodically
		task.spawn(function()
			while gameStarted do
				task.wait(1) -- Check every second

				-- Check Survival win condition
				if checkSurvivalWinCondition() then
					break -- Game ended
				end

				-- Check Infection win condition (if applicable)
				if GameModes.HasEarlyEndCondition(currentGameMode) then
					if checkInfectionWinCondition() then
						break -- Game ended
					end
				end
			end
		end)
	end

end
-- Fixed onPlayerAdded function with robust character loading
local function onPlayerAdded(player)
	playerUsedSkins[player.UserId] = {}
	playerReadyStatus[player.UserId] = false
	playerSpeedBoostActive[player.UserId] = false

	player.CharacterAdded:Connect(function(character)
		print("üîÑ " .. player.Name .. " character loading...")

		-- Wait for character to fully load with timeout
		local humanoid = character:WaitForChild("Humanoid", 10)
		if not humanoid then 
			warn("‚ö†Ô∏è Failed to load humanoid for " .. player.Name)
			return 
		end

		-- Extra wait for network replication
		task.wait(0.5)

		-- Save original avatar FIRST (critical!)
		saveOriginalAvatar(player, character)

		-- Load custom animations for this player
		task.delay(0.5, function()
			AnimationHandler.LoadAnimations(player, character)
			-- Enable animations by default (lobby/survivor state)
			AnimationHandler.EnableCustomAnimations(player)
		end)

		-- Set default properties
		humanoid.WalkSpeed = NORMAL_SPEED
		setCharacterScale(character, NORMAL_SCALE)

		setupTouchDetection(character)

		humanoid.Died:Connect(function()
			print(player.Name .. " died!")

			playerSpeedBoostActive[player.UserId] = false
			ChaserAbilities.ClearAbilities(player)

			if isChaser(player) and gameStarted then
				local index = table.find(allChasers, player)
				if index then
					table.remove(allChasers, index)
				end

				if not GameModes.AllowsMultipleChasers(currentGameMode) then
					local allPlayers = Players:GetPlayers()
					local readyPlayers = {}
					for _, p in ipairs(allPlayers) do
						if isPlayerReady(p) and p ~= player and p.Character then
							table.insert(readyPlayers, p)
						end
					end

					if #readyPlayers > 0 then
						local newChaser = readyPlayers[math.random(1, #readyPlayers)]
						currentChaser = nil
						wait(0.5)
						if newChaser and newChaser.Character then
							makeChaser(newChaser, false)
						end
					end
				else
					if #allChasers == 0 then
						print("‚ö†Ô∏è No chasers remaining! Ending game...")
						endGame()
					else
						if GameModes.HasEarlyEndCondition(currentGameMode) then
							checkInfectionWinCondition()
						end
					end
				end
			elseif GameModes.HasEarlyEndCondition(currentGameMode) and gameStarted then
				checkInfectionWinCondition()
			end
		end)

		-- Wait for physics to stabilize
		task.wait(0.3)

		-- Force teleport to lobby with retry
		local success = teleportToSpawn(player, LobbySpawn, 5)

		if not success then
			warn("‚ö†Ô∏è Initial teleport failed for " .. player.Name .. ", trying alternative method...")
			task.spawn(function()
				for i = 1, 3 do
					task.wait(1)
					if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
						player.Character.HumanoidRootPart.CFrame = LobbySpawn.CFrame + Vector3.new(0, 3, 0)
						print("‚úÖ Alternative teleport successful for " .. player.Name)
						break
					end
				end
			end)
		end

		-- Update client UI
		updateSkinEvent:FireClient(player, "Normal Avatar")

		-- Remove any chaser effects
		removeEffects(character)

		if gameStarted then
			print("‚úÖ " .. player.Name .. " spawned to lobby (round in progress)")
		else
			print("‚úÖ " .. player.Name .. " spawned to lobby (waiting for round)")
		end
	end)

	-- Handle if character already exists
	if player.Character then
		print("üîÑ " .. player.Name .. " already has character, setting up...")

		task.wait(0.5)

		-- Save avatar
		saveOriginalAvatar(player, player.Character)

		-- Load custom animations
		task.delay(0.5, function()
			AnimationHandler.LoadAnimations(player, player.Character)
			AnimationHandler.EnableCustomAnimations(player)
		end)

		-- Force teleport to lobby with retry
		teleportToSpawn(player, LobbySpawn, 5)

		-- Update UI
		updateSkinEvent:FireClient(player, "Normal Avatar")
	end
end
local function onPlayerRemoving(player)
	-- Clean up animations
	AnimationHandler.CleanupAnimations(player)

	playerUsedSkins[player.UserId] = nil
	playerOriginalDescriptions[player.UserId] = nil
	playerReadyStatus[player.UserId] = nil
	playerSpeedBoostActive[player.UserId] = nil
	eliminationCooldowns[player.UserId] = nil
	ChaserAbilities.ClearAbilities(player)

	local wasChaser = isChaser(player)

	if wasChaser then
		print("üö® A chaser left the game!")

		local index = table.find(allChasers, player)
		if index then
			table.remove(allChasers, index)
		end

		if player.Character then
			removeEffects(player.Character)
		end

		if not GameModes.AllowsMultipleChasers(currentGameMode) then
			-- Single-chaser mode
			currentChaser = nil
			ChaserAbilities.SetCurrentChaser(nil)

			local allPlayers = Players:GetPlayers()
			local readyPlayers = {}
			for _, p in ipairs(allPlayers) do
				if isPlayerReady(p) and p ~= player and p.Character then
					table.insert(readyPlayers, p)
				end
			end

			if #readyPlayers < 1 then
				print("‚ö†Ô∏è Not enough players remaining. Ending game...")
				if gameStarted then
					endGame()
				end
			elseif #readyPlayers == 1 then
				print("‚ö†Ô∏è Only 1 player remaining. Ending game...")
				if gameStarted then
					endGame()
				end
			elseif gameStarted then
				task.wait(0.5)
				local randomPlayer = readyPlayers[math.random(1, #readyPlayers)]
				if randomPlayer and randomPlayer.Character then
					print("‚úÖ New chaser selected: " .. randomPlayer.Name)
					makeChaser(randomPlayer, false)
				end
			end
		else
			-- Multi-chaser mode
			if #allChasers == 0 and gameStarted then
				print("‚ö†Ô∏è No chasers remaining. Ending game...")
				endGame()
			elseif gameStarted and GameModes.HasEarlyEndCondition(currentGameMode) then
				checkInfectionWinCondition()
			end
		end
	else
		-- A survivor left
		if GameModes.HasEarlyEndCondition(currentGameMode) and gameStarted then
			checkInfectionWinCondition()
		end
	end
end

Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

-- Setup game state listener
local function setupGameStateListener()
	local serverComm = ReplicatedStorage:WaitForChild("ServerGameState", 30)
	if not serverComm then
		warn("‚ùå CRITICAL: ServerGameState not found!")
		return
	end

	print("üîó Connecting to ServerGameState...")

	serverComm.Event:Connect(function(state)
		print("üì° Main Game Script received signal: " .. tostring(state))
		if state == "start" then
			print("üöÄ STARTING GAME NOW!")
			startGame()
		elseif state == "end" then
			print("üõë ENDING GAME NOW!")
			endGame()
		end
	end)

	print("‚úÖ Game state listener setup complete!")
end

-- Listen for player ready signals
local playerReadyEvent = ReplicatedStorage:WaitForChild("PlayerReady", 30)
if playerReadyEvent then
	playerReadyEvent.OnServerEvent:Connect(function(player)
		playerReadyStatus[player.UserId] = true
		print("‚úÖ Main Game: " .. player.Name .. " is ready!")
	end)
end

setupGameStateListener()
print("‚úÖ MainLogic script fully loaded!")

-- IMPORTANT: Handle players who joined before MainLogic loaded
for _, player in ipairs(Players:GetPlayers()) do
	print("üîß Handling existing player: " .. player.Name)
	onPlayerAdded(player)
end

-- Create cleanup function for escaped players
local function cleanupEscapedPlayer(player)
	if not player or not player.Character then return end

	removeEffects(player.Character)
	restoreOriginalAvatar(player, player.Character)
	ChaserAbilities.ClearAbilities(player)
	GunSystem.RemoveGun(player)

	local humanoid = player.Character:FindFirstChild("Humanoid")
	if humanoid then
		humanoid.WalkSpeed = NORMAL_SPEED
	end

	playerSpeedBoostActive[player.UserId] = false
	AnimationHandler.EnableCustomAnimations(player)
end

-- Register cleanup function with Map2EscapeSystem
Map2EscapeSystem.SetCleanupFunction(cleanupEscapedPlayer)

-- NEW: Position verification loop - catches players who fail to teleport
task.spawn(function()
	while true do
		task.wait(5) -- Check every 5 seconds

		if not gameStarted then
			-- During lobby - ensure everyone is at lobby spawn
			for _, player in ipairs(Players:GetPlayers()) do
				if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					local hrp = player.Character.HumanoidRootPart
					local distanceFromLobby = (hrp.Position - LobbySpawn.Position).Magnitude

					-- If player is far from lobby but game isn't active, teleport them
					if distanceFromLobby > 200 and isPlayerReady(player) then
						warn("üîß Position fix: " .. player.Name .. " stuck far from lobby, teleporting back...")
						teleportToSpawn(player, LobbySpawn, 3)
					end
				end
			end
		else
			-- During game - ensure chasers and survivors are in correct positions
			for _, player in ipairs(Players:GetPlayers()) do
				if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					local hrp = player.Character.HumanoidRootPart

					-- Check if player fell through the map (Y < -100)
					if hrp.Position.Y < -100 then
						warn("üîß Position fix: " .. player.Name .. " fell through map, respawning...")

						if isChaser(player) then
							-- Respawn chaser at chaser spawn
							local chaserSpawn = currentMap == "Map1" and Map1K or Map2K or Map3K
							teleportToSpawn(player, chaserSpawn, 3)
						else
							-- Respawn survivor at survivor spawn
							local survivorSpawn = currentMap == "Map1" and Map1S or Map2S or Map3S
							teleportToSpawn(player, survivorSpawn, 3)
						end
					end
				end
			end
		end
	end
end)

-- NEW: Periodic chaser verification to catch any desyncs
task.spawn(function()
	while true do
		task.wait(2) -- Check every 2 seconds during game

		if gameStarted then
			-- Clean up invalid chasers (disconnected players)
			for i = #allChasers, 1, -1 do
				if not allChasers[i] or not allChasers[i].Parent then
					warn("üîß Removing invalid chaser from list")
					table.remove(allChasers, i)
				end
			end

			-- Verify currentChaser is still valid
			if currentChaser and (not currentChaser.Parent or not table.find(allChasers, currentChaser)) then
				warn("üîß Current chaser is invalid, resetting")
				currentChaser = allChasers[1] or nil
			end

			-- Send update to all clients to ensure sync
			local chaserNames = getCurrentChaserNames()
			updateChaserEvent:FireAllClients(chaserNames)
		end
	end
end)
